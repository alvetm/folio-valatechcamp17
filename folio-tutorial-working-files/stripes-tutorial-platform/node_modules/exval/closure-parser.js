
// TODO handle functions names
// TODO handle `var` on function level (unlike `const` and `let`)

class ClosureParser {
  constructor(node) {
    this.identifiers = new Set();
    this.declarations = new Set();
    this.funcDeclartion = new Set();

    this.parse(node);
  }

  add(name) {
    if (this.declarations.has(name)) return;

    this.identifiers.add(name);
  }

  parse(node) {
    if (Array.isArray(node.params)) {
      node.params.forEach(param => this.parseVar(param));
    }

    switch (node.type) {
      case 'Identifier': {
        this.add(node.name);
        return;
      }
      case 'VariableDeclarator': {
        this.parseVar(node.id);
        if (node.init) this.parse(node.init);
        return;
      }
      case 'BinaryExpression': {
        this.parse(node.left);
        this.parse(node.right);
        return;
      }
      case 'UpdateExpression': {
        this.parse(node.argument);
        return;
      }
      case 'BlockStatement': {
        const closure = new this.constructor(node);
        closure.identifiers.forEach(name => this.add(name));
        return;
      }
      default: {
        if (!node.body) {
          throw new SyntaxError(`Node '${node.type}' missing a body`);
        }

        if (Array.isArray(node.body)) {
          node.body.forEach(n => this.parse(n));
        } else {
          this.parse(node.body, node);
        }
      }
    }
  }

  parseVar(param) {
    if (param.type === 'Identifier') {
      this.declarations.add(param.name);
      return;
    }

    if (param.type !== 'AssignmentPattern') {
      throw new SyntaxError(`Unknown param type '${param.type}'`);
    }

    this.parse(param.right);
    this.parseVar(param.left);
  }
}

module.exports = ClosureParser;
